diff --git a/.gitignore b/.gitignore
index e506e00f..2164e72f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -53 +53,4 @@ site
 e2e-test-report/
+
+# Cache
+.cache/
diff --git a/.yarn/plugins/@yarnpkg/plugin-backstage.cjs b/.yarn/plugins/@yarnpkg/plugin-backstage.cjs
index d71dd8cc..67bbc26c 100644
--- a/.yarn/plugins/@yarnpkg/plugin-backstage.cjs
+++ b/.yarn/plugins/@yarnpkg/plugin-backstage.cjs
@@ -5,3 +5,3 @@ name: "@yarnpkg/plugin-backstage",
 factory: function (require) {
-"use strict";var plugin=(()=>{var j=Object.create;var R=Object.defineProperty;var M=Object.getOwnPropertyDescriptor;var F=Object.getOwnPropertyNames;var W=Object.getPrototypeOf,N=Object.prototype.hasOwnProperty;var c=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(r,t)=>(typeof require<"u"?require:r)[t]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var G=(e,r)=>{for(var t in r)R(e,t,{get:r[t],enumerable:!0})},T=(e,r,t,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(let o of F(r))!N.call(e,o)&&o!==t&&R(e,o,{get:()=>r[o],enumerable:!(n=M(r,o))||n.enumerable});return e};var S=(e,r,t)=>(t=e!=null?j(W(e)):{},T(r||!e||!e.__esModule?R(t,"default",{value:e,enumerable:!0}):t,e)),I=e=>T(R({},"__esModule",{value:!0}),e);var te={};G(te,{default:()=>re});var P=c("@yarnpkg/core");var w=c("@yarnpkg/core");var U=S(c("assert")),A=c("semver"),y=c("@yarnpkg/fslib");var m=S(c("fs")),p=c("path");function L(e,r){let t=e;for(let n=0;n<1e3;n++){let o=(0,p.resolve)(t,"package.json");if(m.default.existsSync(o)&&r(o))return t;let i=(0,p.dirname)(t);if(i===t)return;t=i}throw new Error(`Iteration limit reached when searching for root package.json at ${e}`)}function _(e){let r=L(e,()=>!0);if(!r)throw new Error(`No package.json found while searching for package root of ${e}`);return r}function J(e){if(!m.default.existsSync((0,p.resolve)(e,"src")))throw new Error("Tried to access monorepo package root dir outside of Backstage repository");return(0,p.resolve)(e,"../..")}function b(e){let r=_(e),t=m.default.realpathSync(process.cwd()).replace(/^[a-z]:/,s=>s.toLocaleUpperCase("en-US")),n="",o=()=>(n||(n=J(r)),n),a="",i=()=>(a||(a=L(t,s=>{try{let f=m.default.readFileSync(s,"utf8");return!!JSON.parse(f).workspaces}catch(f){throw new Error(`Failed to parse package.json file while searching for root, ${f}`)}})??t),a);return{ownDir:r,get ownRoot(){return o()},targetDir:t,get targetRoot(){return i()},resolveOwn:(...s)=>(0,p.resolve)(r,...s),resolveOwnRoot:(...s)=>(0,p.resolve)(o(),...s),resolveTarget:(...s)=>(0,p.resolve)(t,...s),resolveTargetRoot:(...s)=>(0,p.resolve)(i(),...s)}}var x="backstage.json";var V=e=>{let r=!1,t;return()=>(r||(t=e(),r=!0),t)};var u=c("@yarnpkg/fslib");var C=()=>u.npath.toPortablePath(b(u.npath.fromPortablePath(u.ppath.cwd())).targetRoot);var h=V(()=>{let e=y.ppath.join(C(),x),r=null;try{r=(0,A.valid)(y.xfs.readJsonSync(e).version),(0,U.default)(r!==null)}catch{throw new Error("Valid version string not found in backstage.json")}return r});var d=c("@yarnpkg/core");var H="https://versions.backstage.io",z="https://raw.githubusercontent.com/backstage/versions/main";function K(e,r){return new Promise((t,n)=>{let o=setTimeout(()=>{r.aborted||t()},e);r.addEventListener("abort",()=>{clearTimeout(o),n(new Error("Aborted"))})})}async function Y(e,r,t){let n=new AbortController,o=new AbortController,a=e(n.signal).then(s=>(o.abort(),s)),i=K(t,o.signal).then(()=>r(o.signal)).then(s=>(n.abort(),s));return Promise.any([a,i]).catch(()=>a)}async function D(e){let r=encodeURIComponent(e.version),t=e.fetch??fetch,n=await Y(o=>t(`${H}/v1/releases/${r}/manifest.json`,{signal:o}),o=>t(`${z}/v1/releases/${r}/manifest.json`,{signal:o}),500);if(n.status===404)throw new Error(`No release found for ${e.version} version`);if(n.status!==200)throw new Error(`Unexpected response status ${n.status} when fetching release from ${n.url}.`);return n.json()}var g="backstage:";var k=async(e,r)=>{let t=d.structUtils.stringifyIdent(e),n=d.structUtils.parseRange(e.range);if(n.protocol!==g)throw new Error(`Unsupported version protocol in version range "${e.range}" for package ${t}`);if(n.selector!=="^")throw new Error(`Unexpected version selector "${n.selector}" for package ${t}`);let o=h(),i=(await D({version:o,fetch:async s=>{let f=await d.httpUtils.get(s,{configuration:r,jsonResponse:!0});return{status:200,url:s,json:()=>f}}})).packages.find(s=>s.name===t);if(!i)throw new Error(`Package ${t} not found in manifest for Backstage v${o}. This means the specified package is not included in this Backstage release. This may imply the package has been replaced with an alternative - please review the documentation for the package. If you need to continue using this package, it will be necessary to switch to manually managing its version.`);return i.version};var q=e=>w.structUtils.parseRange(e).protocol===g,Q=(e,r,t)=>e!=="dependencies"?e:t.manifest.ensureDependencyMeta(w.structUtils.makeDescriptor(r,"unknown")).optional?"optionalDependencies":e,O=async(e,r)=>{for(let t of["dependencies","devDependencies"]){let n=Array.from(e.manifest.getForScope(t).values()).filter(o=>o.range.startsWith(g));for(let o of n){let a=w.structUtils.stringifyIdent(o);if(w.structUtils.parseRange(o.range).selector!=="^")throw new Error(`Unexpected version range "${o.range}" for dependency on "${a}"`);let s=Q(t,o,e);r[s][a]=`^${await k(o,e.project.configuration)}`}}if(["dependencies","devDependencies","optionalDependencies"].some(t=>Object.values(r[t]??{}).some(q)))throw new Error(`Failed to replace all "backstage:" ranges in manifest for ${r.name}`)};var $=c("@yarnpkg/core");var B=async(e,r)=>{let t=$.structUtils.parseRange(e.range);if(t.protocol!==g)return e;if(t.selector!=="^")throw new Error(`Invalid backstage: version range found: ${e.range}`);return $.structUtils.bindDescriptor(e,{backstage:h(),npm:await k(e,r.configuration)})};var l=c("@yarnpkg/core"),E=c("@yarnpkg/plugin-npm");var v=class e{static protocol=g;supportsDescriptor=r=>r.range.startsWith(e.protocol);async getCandidates(r,t,n){let o=l.structUtils.parseRange(r.range).params?.npm;if(!o||Array.isArray(o))throw new Error(`Missing npm parameter on backstage: range "${r.range}"`);return new E.NpmSemverResolver().getCandidates(l.structUtils.makeDescriptor(r,`npm:^${o}`),t,n)}getResolutionDependencies(r){let t=l.structUtils.parseRange(r.range).params?.npm;if(!t)throw new Error(`Missing npm parameter on backstage: range "${r.range}".`);return{[l.structUtils.stringifyIdent(r)]:l.structUtils.makeDescriptor(r,`npm:^${t}`)}}async getSatisfying(r,t,n,o){let a=r,i=l.structUtils.parseRange(a.range);if(i.protocol===g){let s=i.params?.npm;a=l.structUtils.makeDescriptor(r,`npm:^${s}`)}return new E.NpmSemverResolver().getSatisfying(a,t,n,o)}bindDescriptor=r=>r;supportsLocator=()=>!1;shouldPersistResolution=()=>{throw new Error("Unreachable: BackstageNpmResolver should never persist resolution as it uses npm: protocol")};resolve=async()=>{throw new Error("Unreachable: BackstageNpmResolver should never resolve as it uses npm: protocol")}};var X="\x1B[31;1m",Z="\x1B[0m";P.semverUtils.satisfiesWithPrereleases(P.YarnVersion,"^4.1.1")||(console.error(),console.error(`${X}Unsupported yarn version${Z}: The Backstage yarn plugin only works with yarn ^4.1.1. Please upgrade yarn, or remove this plugin with "yarn plugin remove @yarnpkg/plugin-backstage".`),console.error());var ee={hooks:{reduceDependency:B,beforeWorkspacePacking:O},resolvers:[v]},re=ee;return I(te);})();
+"use strict";var plugin=(()=>{var F=Object.create;var y=Object.defineProperty;var _=Object.getOwnPropertyDescriptor;var N=Object.getOwnPropertyNames;var G=Object.getPrototypeOf,I=Object.prototype.hasOwnProperty;var p=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(r,t)=>(typeof require<"u"?require:r)[t]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var J=(e,r)=>{for(var t in r)y(e,t,{get:r[t],enumerable:!0})},S=(e,r,t,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(let o of N(r))!I.call(e,o)&&o!==t&&y(e,o,{get:()=>r[o],enumerable:!(n=_(r,o))||n.enumerable});return e};var L=(e,r,t)=>(t=e!=null?F(G(e)):{},S(r||!e||!e.__esModule?y(t,"default",{value:e,enumerable:!0}):t,e)),z=e=>S(y({},"__esModule",{value:!0}),e);var ae={};J(ae,{default:()=>se});var P=p("@yarnpkg/core");var w=p("@yarnpkg/core");var j=L(p("assert")),W=p("semver"),v=p("@yarnpkg/fslib");var u=L(p("fs")),g=p("path");function V(e,r){let t=e;for(let n=0;n<1e3;n++){let o=(0,g.resolve)(t,"package.json");if(u.default.existsSync(o)&&r(o))return t;let i=(0,g.dirname)(t);if(i===t)return;t=i}throw new Error(`Iteration limit reached when searching for root package.json at ${e}`)}function K(e){let r=V(e,()=>!0);if(!r)throw new Error(`No package.json found while searching for package root of ${e}`);return r}function Y(e){if(!u.default.existsSync((0,g.resolve)(e,"src")))throw new Error("Tried to access monorepo package root dir outside of Backstage repository");return(0,g.resolve)(e,"../..")}function b(e){let r=K(e),t=u.default.realpathSync(process.cwd()).replace(/^[a-z]:/,s=>s.toLocaleUpperCase("en-US")),n="",o=()=>(n||(n=Y(r)),n),a="",i=()=>(a||(a=V(t,s=>{try{let m=u.default.readFileSync(s,"utf8");return!!JSON.parse(m).workspaces}catch(m){throw new Error(`Failed to parse package.json file while searching for root, ${m}`)}})??t),a);return{ownDir:r,get ownRoot(){return o()},targetDir:t,get targetRoot(){return i()},resolveOwn:(...s)=>(0,g.resolve)(r,...s),resolveOwnRoot:(...s)=>(0,g.resolve)(o(),...s),resolveTarget:(...s)=>(0,g.resolve)(t,...s),resolveTargetRoot:(...s)=>(0,g.resolve)(i(),...s)}}var x="backstage.json";var A=e=>{let r=!1,t;return()=>(r||(t=e(),r=!0),t)};var h=p("@yarnpkg/fslib");var C=()=>h.npath.toPortablePath(b(h.npath.fromPortablePath(h.ppath.cwd())).targetRoot);var k=A(()=>{let e=v.ppath.join(C(),x),r=null;try{r=(0,W.valid)(v.xfs.readJsonSync(e).version),(0,j.default)(r!==null)}catch{throw new Error("Valid version string not found in backstage.json")}return r});var d=p("@yarnpkg/core");var q="https://versions.backstage.io",Q="https://raw.githubusercontent.com/backstage/versions/main";function X(e,r){return new Promise((t,n)=>{let o=setTimeout(()=>{r.aborted||t()},e);r.addEventListener("abort",()=>{clearTimeout(o),n(new Error("Aborted"))})})}async function Z(e,r,t){let n=new AbortController,o=new AbortController,a=e(n.signal).then(s=>(o.abort(),s)),i=X(t,o.signal).then(()=>r(o.signal)).then(s=>(n.abort(),s));return Promise.any([a,i]).catch(()=>a)}async function D(e){let r=encodeURIComponent(e.version),t=e.fetch??fetch,n=e.versionsBaseUrl??q,o=e.gitHubRawBaseUrl??Q,a=await Z(i=>t(`${n}/v1/releases/${r}/manifest.json`,{signal:i}),i=>t(`${o}/v1/releases/${r}/manifest.json`,{signal:i}),500);if(a.status===404)throw new Error(`No release found for ${e.version} version`);if(a.status!==200)throw new Error(`Unexpected response status ${a.status} when fetching release from ${a.url}.`);return a.json()}var c="backstage:";var l=async(e,r)=>{let t=d.structUtils.stringifyIdent(e),n=d.structUtils.parseRange(e.range);if(n.protocol!==c)throw new Error(`Unsupported version protocol in version range "${e.range}" for package ${t}`);if(n.selector!=="^")throw new Error(`Unexpected version selector "${n.selector}" for package ${t}`);let o=k(),i=(await D({version:o,fetch:async s=>{let m=await d.httpUtils.get(s,{configuration:r,jsonResponse:!0});return{status:200,url:s,json:()=>m}}})).packages.find(s=>s.name===t);if(!i)throw new Error(`Package ${t} not found in manifest for Backstage v${o}. This means the specified package is not included in this Backstage release. This may imply the package has been replaced with an alternative - please review the documentation for the package. If you need to continue using this package, it will be necessary to switch to manually managing its version.`);return i.version};var ee=e=>w.structUtils.parseRange(e).protocol===c,re=(e,r,t)=>e!=="dependencies"?e:t.manifest.ensureDependencyMeta(w.structUtils.makeDescriptor(r,"unknown")).optional?"optionalDependencies":e,B=async(e,r)=>{for(let t of["dependencies","devDependencies"]){let n=Array.from(e.manifest.getForScope(t).values()).filter(o=>o.range.startsWith(c));for(let o of n){let a=w.structUtils.stringifyIdent(o);if(w.structUtils.parseRange(o.range).selector!=="^")throw new Error(`Unexpected version range "${o.range}" for dependency on "${a}"`);let s=re(t,o,e);r[s][a]=`^${await l(o,e.project.configuration)}`}}if(["dependencies","devDependencies","optionalDependencies"].some(t=>Object.values(r[t]??{}).some(ee)))throw new Error(`Failed to replace all "backstage:" ranges in manifest for ${r.name}`)};var O=p("@yarnpkg/core");var $=async(e,r)=>{let t=O.structUtils.parseRange(e.range);if(t.protocol!==c)return e;if(t.selector!=="^")throw new Error(`Invalid backstage: version range found: ${e.range}`);return O.structUtils.bindDescriptor(e,{backstage:k(),npm:await l(e,r.configuration)})};var H=p("@yarnpkg/core");var U=async(e,r,t,n)=>{let o=H.structUtils.parseRange(t.range);if(t.scope==="backstage"&&o.protocol!==c)try{await l(t,e.project.configuration),console.info(`Setting ${t.scope}/${t.name} to ${c}^`),t.range=`${c}^`}catch{}};var M=p("@yarnpkg/core");var E=async(e,r,t,n)=>{let o=M.structUtils.parseRange(n.range);if(n.scope==="backstage"&&o.protocol!==c)try{await l(n,e.project.configuration),console.warn(`${n.name} should be set to "${c}^" instead of "${n.range}". Make sure this change is intentional and not a mistake.`)}catch{}};var f=p("@yarnpkg/core"),T=p("@yarnpkg/plugin-npm");var R=class e{static protocol=c;supportsDescriptor=r=>r.range.startsWith(e.protocol);async getCandidates(r,t,n){let o=f.structUtils.parseRange(r.range).params?.npm;if(!o||Array.isArray(o))throw new Error(`Missing npm parameter on backstage: range "${r.range}"`);return new T.NpmSemverResolver().getCandidates(f.structUtils.makeDescriptor(r,`npm:^${o}`),t,n)}getResolutionDependencies(r){let t=f.structUtils.parseRange(r.range).params?.npm;if(!t)throw new Error(`Missing npm parameter on backstage: range "${r.range}".`);return{[f.structUtils.stringifyIdent(r)]:f.structUtils.makeDescriptor(r,`npm:^${t}`)}}async getSatisfying(r,t,n,o){let a=r,i=f.structUtils.parseRange(a.range);if(i.protocol===c){let s=i.params?.npm;a=f.structUtils.makeDescriptor(r,`npm:^${s}`)}return new T.NpmSemverResolver().getSatisfying(a,t,n,o)}bindDescriptor=r=>r;supportsLocator=()=>!1;shouldPersistResolution=()=>{throw new Error("Unreachable: BackstageNpmResolver should never persist resolution as it uses npm: protocol")};resolve=async()=>{throw new Error("Unreachable: BackstageNpmResolver should never resolve as it uses npm: protocol")}};var te="\x1B[31;1m",oe="\x1B[0m";P.semverUtils.satisfiesWithPrereleases(P.YarnVersion,"^4.1.1")||(console.error(),console.error(`${te}Unsupported yarn version${oe}: The Backstage yarn plugin only works with yarn ^4.1.1. Please upgrade yarn, or remove this plugin with "yarn plugin remove @yarnpkg/plugin-backstage".`),console.error());var ne={hooks:{afterWorkspaceDependencyAddition:U,afterWorkspaceDependencyReplacement:E,reduceDependency:$,beforeWorkspacePacking:B},resolvers:[R]},se=ne;return z(ae);})();
 return plugin;
diff --git a/.yarnrc.yml b/.yarnrc.yml
index 88db579e..abcf9099 100644
--- a/.yarnrc.yml
+++ b/.yarnrc.yml
@@ -3,5 +3,5 @@ nodeLinker: node-modules
 plugins:
-  - checksum: 2eda215600fa289952383d999f87e6fa46a333fd737a8a221a1e2326d4c95a2d694510b5e6aa5a3ef5b8927b48ce7ea1d5783efc4be18d5f87cf57d5fa16b966
+  - checksum: 3f0f3e2debfccaa85999007e42aed55409ba895e71bf2cfde4cf49210472b17d007dfefdffd38fc3685ceadaa842b5673cac68252766aec50b37837c8b086dfb
     path: .yarn/plugins/@yarnpkg/plugin-backstage.cjs
-    spec: "https://versions.backstage.io/v1/releases/1.39.0-next.2/yarn-plugin"
+    spec: "https://versions.backstage.io/v1/releases/1.40.1/yarn-plugin"
 
diff --git a/backstage.json b/backstage.json
index fdee4d77..717297d3 100644
--- a/backstage.json
+++ b/backstage.json
@@ -1,3 +1,3 @@
 {
-  "version": "1.39.0-next.2"
+  "version": "1.40.1"
 }
diff --git a/yarn.lock b/yarn.lock
deleted file mode 100644
index 46a911dd..00000000
--- a/yarn.lock
+++ /dev/null
@@ -1,28 +0,0 @@
-# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
-# yarn lockfile v1
-
-
-"@google-cloud/storage@^7.0.0":
-  version "7.14.0"
-  resolved "https://registry.yarnpkg.com/@google-cloud/storage/-/storage-7.14.0.tgz#eda9715f68507949214af804c906eba6d168a214"
-  integrity sha512-H41bPL2cMfSi4EEnFzKvg7XSb7T67ocSXrmF7MPjfgFB0L6CKGzfIYJheAZi1iqXjz6XaCT1OBf6HCG5vDBTOQ==
-
-"@octokit/types@npm:^13.0.0":
-  version "13.6.2"
-  resolved "https://registry.yarnpkg.com/@octokit/types/-/types-13.6.2.tgz#e10fc4d2bdd65d836d1ced223b03ad4cfdb525bd"
-  integrity sha512-WpbZfZUcZU77DrSW4wbsSgTPfKcp286q3ItaIgvSbBpZJlu6mnYXAkjZz6LVZPXkEvLIM8McanyZejKTYUHipA==
-
-"@octokit/types@npm:^13.1.0":
-  version "13.6.2"
-  resolved "https://registry.yarnpkg.com/@octokit/types/-/types-13.6.2.tgz#e10fc4d2bdd65d836d1ced223b03ad4cfdb525bd"
-  integrity sha512-WpbZfZUcZU77DrSW4wbsSgTPfKcp286q3ItaIgvSbBpZJlu6mnYXAkjZz6LVZPXkEvLIM8McanyZejKTYUHipA==
-
-"@octokit/types@npm:^13.5.0":
-  version "13.6.2"
-  resolved "https://registry.yarnpkg.com/@octokit/types/-/types-13.6.2.tgz#e10fc4d2bdd65d836d1ced223b03ad4cfdb525bd"
-  integrity sha512-WpbZfZUcZU77DrSW4wbsSgTPfKcp286q3ItaIgvSbBpZJlu6mnYXAkjZz6LVZPXkEvLIM8McanyZejKTYUHipA==
-
-"@octokit/openapi-types@^22.2.0":
-  version "22.2.0"
-  resolved "https://registry.yarnpkg.com/@octokit/openapi-types/-/openapi-types-22.2.0.tgz#75aa7dcd440821d99def6a60b5f014207ae4968e"
-  integrity sha512-QBhVjcUa9W7Wwhm6DBFu6ZZ+1/t/oYxqc2tp81Pi41YNuJinbFRx8B133qVOrAaBbF7D/m0Et6f9/pZt9Rc+tg==
